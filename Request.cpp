//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : SAVI/VDCPlanner
//  @ File Name : Request.cpp
//  @ Date : 17/04/2013
//  @ Author : Maissa Jabri
//
//

#include "Request.hpp"
#include "provisioning_module.h"
#include <iostream>
#include <string>
#include <sstream>

struct arg_struct2 {
	vector<string>* input_str;
	string vdc_id;
	Request * req;
};


Request::Request(int reqNumber, int type, int numberNodes, int split,
		time_t arrTime, int topo, double duration, double revenue,
		double availability) {
	this->reqNumber = reqNumber;
	this->type = type;
	this->split = split;
	this->arrTime = arrTime;
	this->topo = topo;
	this->duration = duration;
	this->revenue = revenue;
	this->availability = availability;
	this->numberNodes = numberNodes;
}

Request::Request(void) {

}

Request::~Request(void) {

}

string Request::GetName() {
	return this->name;
}

void Request::SetName(string name) {
	this->name = name;
}

string Request::GetUserName() {
	return this->userName;
}

void Request::SetUserName(string userName) {
	this->userName = userName;
}

int Request::GetRequestNumber() {
	return this->reqNumber;
}

void Request::SetRequestNumber(int reqNumber) {
	this->reqNumber = reqNumber;
}

int Request::GetSplit() {
	return this->split;
}

void Request::SetSplit(int split) {
	this->split = split;
}

time_t Request::GetArrTime() {
	return this->arrTime;
}

void Request::SetArrTime(time_t arrTime) {
	this->arrTime = arrTime;
}

int Request::GetTopo() {
	return this->topo;
}

void Request::SetTopo(int topo) {
	this->topo = topo;
}

double Request::GetDuration() {
	return this->duration;
}

void Request::SetDuration(double duration) {
	this->duration = duration;
}

double Request::GetRevenue() {
	return this->revenue;
}

void Request::SetRevenue(double revenue) {
	this->revenue = revenue;
}

int Request::GetStatus() {
	return this->status;
}

void Request::CalculateStatus() {
	//the vdc is active if all the nodes are active
	//variables
	ProvisioningModule prModule;
	ostringstream vdc_id;
	string vm_name, status, task_state, power_state, ip, private_ip, public_ip;
	std::list<Priority_group>::iterator it1;
	std::list<Virtual_node>::iterator it2;
	std::list<Path>::iterator it3;

	for (it1 = this->groups.begin(); it1 != this->groups.end(); it1++) {
		for (it2 = it1->GetNodes()->begin(); it2 != it1->GetNodes()->end();
				it2++) {
			//ostringstream vdc_id;
			//UNCOMMENT IN THE CLUSTER--------
			//vdc_id << "VDC_" << this->GetRequestNumber() << "_VM"<< it2->GetId();

			//UNCOMMENT IN THE CLUSTER--------
			ostringstream out;
			out << prModule.sendStatusVM(it2->GetName()) << endl;
			//cout << vdc_id.str() << " vs " << it2->GetName()<<endl;
			//out << prModule.sendStatusVM(it2->GetName()) << endl;
			//cout <<" OUTPUT for VM_"<<it2->GetId()<<endl<< out.str() << endl;
			std::istringstream iss(out.str());
			//token: vm_name;status;task_state;power_state;private_ip,public_ip
			getline(iss, vm_name, ';');
			//for testing-------printf("%s\n", vm_name.c_str());
			getline(iss, status, ';');
			//for testing-------printf("%s\n", status.c_str());
			it2->SetStatus(status);
			//getline(iss, task_state, ';');
			//for testing-------printf("%s\n", task_state.c_str());
			//it2->SetTaskState(task_state);
			//getline(iss, power_state, ';');
			//for testing-------printf("%s\n", power_state.c_str());
			//it2->SetPowerState(power_state);
			getline(iss, ip, ';');
			//std::istringstream iss2(ip);
			//getline(iss2, private_ip, ',');
			//std::istringstream temp(private_ip);
			//getline(temp, private_ip, '\n');
			//for testing-------printf("%s\n", private_ip.c_str());
			//it2->SetPrivateIp(private_ip);
			it2->SetPrivateIp(ip);
			cout << "test test :  " << endl;
		}
		cout << "test test 2 :  " << endl;
	}
	cout << "before second loop" << endl;

	for (it3 = this->links.begin(); it3 != this->links.end(); it3++) {
		ostringstream out;
		cout << "Call here" << endl;
		cout << "before call src: "
				<< this->GetNodeById(it3->GetSourceNode_id())->GetId() << endl;
		cout << "before call dst: " << this->GetNodeById(it3->GetDestinationNode_id())->GetId()
				<< endl;

		 //UNCOMMENT IN THE CLUSTER--------
		 cout<< "before call src: " << this->GetNodeById(it3->GetSourceNode_id())->GetPrivateIp() << " dst: " << this->GetNodeById(it3->GetDestinationNode_id())->GetId()<< endl;
		 if(this->GetNodeById(it3->GetSourceNode_id())->GetPrivateIp() == "" ||  this->GetNodeById(it3->GetDestinationNode_id())->GetPrivateIp()== "")
		 {
		 cout << "any one is empty" << endl;
		 }
		 else
		 {
		 out << prModule.sendLinkStatus(this->GetNodeById(it3->GetSourceNode_id())->GetPrivateIp(),this->GetNodeById(it3->GetDestinationNode_id())->GetPrivateIp(), it3->GetName());
		 //UNCOMMENT IN THE CLUSTER--------
		 cout << out <<endl;
		 it3->SetStatus(out.str());
		 }

	}

}

void Request::SetStatus(int status) {
	this->status = status;
}

void Request::IncrementRevenue(double plus) {
	this->revenue += plus;
}

void Request::DecrementRevenue(double minus) {
	this->revenue -= minus;
}

//id = index +1 in the list
Priority_group* Request::GetGroupById(int id) {

	list<Priority_group>::iterator it1;
	it1 = (this->groups).begin();
	std::advance(it1, id - 1);
	return &(*it1);
}

std::list<Priority_group> * Request::GetGroups() {
	return &(this->groups);
}

std::list<Path> * Request::GetLinks() {
	return &(this->links);
}

int Request::GetNumberNodes() {
	return this->numberNodes;
}

void Request::SetNumberNodes(int numberNodes) {
	this->numberNodes = numberNodes;
}

double Request::GetAvailability() {
	return this->availability;
}

void Request::SetAvailability(double availability) {
	this->availability = availability;
}

mapping * Request::GetMapping() {
	return this->mapping;
}

Virtual_node* Request::GetNodeById(int id) {

	//variables
	std::list<Priority_group>::iterator it1;
	std::list<Virtual_node>::iterator it2;
	bool found = false;

	//operations
	it1 = this->groups.begin();
	while (!found && it1 != this->groups.end()) {

		it2 = it1->GetNodes()->begin();
		while (!found && it2 != it1->GetNodes()->end()) {
			if (it2->GetId() == id) {
				found = true;
				break;
			} else {
				it2++;
			}
		}

		it1++;
	}

	if (found == true) {
		return &(*it2);
	}

}

void Request::SetMapping(class mapping * mapp) {

	//variables
	std::list<Priority_group>::iterator it1;
	std::list<Virtual_node>::iterator it2;
	std::list<Path>::iterator it3;
	ProvisioningModule prModule;
	vector<string> input_str;
	ostringstream vdc_id;
	Config config;

	//operations
	this->mapping = mapp;

	vdc_id << "VDC_" << this->GetRequestNumber();
	for (it1 = this->groups.begin(); it1 != this->groups.end(); it1++) {
		for (it2 = it1->GetNodes()->begin(); it2 != it1->GetNodes()->end();
				it2++) {
			ostringstream vm_id;
			//UNCOMMENT IN THE CLUSTER--------
			//vm_id << vdc_id.str() << "_VM" << it2->GetId();
			//UNCOMMENT IN THE CLUSTER--------
			//cout << vm_id.str() << " vs " << it2->GetName()<<endl;
			prModule.createVM(it2->GetName(),
					it2->GetEmbeddingNode()->GetName(), it2->GetFlavor(),
					config.image_id);// this image is hadoop-image01

		}
	}
	//UNCOMMENT IN THE CLUSTER--------sleep(180);
	for (it3 = this->links.begin(); it3 != this->links.end(); it3++) {
		ostringstream vl_str1, vl_str2, vl_id, vm1_id, vm2_id;
		/*
		 vl_id << vdc_id.str() << "_VL" << it3->GetId();
		 vm1_id << vdc_id.str() << "_VM" << it3->GetSourceNode_id();
		 vm2_id << vdc_id.str() << "_VM" << it3->GetDestinationNode_id();
		 cout << vl_id.str() << " vs " << it3->GetName()<<endl;
		 cout << vm1_id.str() << " vs " << it3->GetSourceNode()->GetName()<<endl;
		 cout << vm2_id.str() << " vs " << it3->GetDestinationNode()->GetName()<<endl;
		 */
		vl_str1 << it3->GetSourceNode()->GetName() << ";"
				<< it3->GetDestinationNode()->GetName() << ";"
				<< it3->GetBandwidth() * 1000 << ";" << it3->GetName();
		vl_str2 << it3->GetDestinationNode()->GetName() << ";"
				<< it3->GetSourceNode()->GetName() << ";"
				<< it3->GetBandwidth() * 1000 << ";" << it3->GetName();
		input_str.push_back(vl_str1.str());
		input_str.push_back(vl_str2.str());
		it3->SetStatus("PROVISIONING");
	}
	/*
	 //UNCOMMENT IN THE CLUSTER--------
	 pthread_t t1;
	 struct arg_struct2 args;
	 args.vdc_id = vdc_id.str();
	 args.input_str = &input_str;
	 args.req = this;
	 pthread_create(&t1, 0, function2, (void *) &args);
	 */

	//for testing-----------
	/*
	 for (std::vector<string>::const_iterator i = input_str.begin();
	 i != input_str.end(); ++i)
	 std::cout << *i << '\n';
	 */
	this->status = STATE_RUNNING;
	prModule.provisionLinks(vdc_id.str(), input_str,this->GetApplication());
	//cout << "VDC id : " << this->reqNumber << " VDC status : " << this->status<< endl;

}

void Request::FreeMapping(Substrate_network* sub) {
	//for testing --------cout << " starting FreeMapping StateMapping = "<< this->mapping->GetStateMapping() << " \n";

	//variables
	std::list<Path>::iterator it1;
	std::list<Substrate_link>::iterator it2;

	//for testing-----------cout<<"FreeMappPathPartial\n";
	it1 = this->GetLinks()->begin();
	//cout << " number of paths : " << this->GetLinks()->size() << "\n";
	while (it1 != this->GetLinks()->end()) {
		//for testing-----------
		//for testing-----------cout << " Attempt to free path with id : " << it1->GetId() << "\n";
		if (!it1->GetSubstrateLinks()->empty()) //this means it is not connecting two nodes hosted in the same physical node
		{
			//cout << " This path has " << it1->GetSubstrateLinks()->size() <<" sub links " <<endl;
			Path * path = &(*it1);
			it2 = it1->GetSubstrateLinks()->begin();
			while (it2 != it1->GetSubstrateLinks()->end()) {
				//it1 = it2->GetEmbeddedPaths()->erase(it1);
				Substrate_link* subLink = sub->GetLinkById(it2->GetId());
				bool found = subLink->removeEmbeddedPath(path);
				//cout<< " for this pah one of the SubLinks : "<<subLink->GetId()<<" return value is : "<<found<<endl<<endl;
				it2 = it1->GetSubstrateLinks()->erase(it2);
			}

		}
		it1++;

	}
	this->mapping->SetStateMapping(STATE_MAP_NODE);
	{
		//variables
		std::list<Priority_group>::iterator it1;
		std::list<Virtual_node>::iterator it2;
		std::list<Virtual_node>::iterator it3;
		std::list<int>::iterator it4;
		Substrate_node * embeddingNode;
		bool found;

		if (!this->groups.empty()) {
			it1 = this->groups.begin();

			while (it1 != this->groups.end()) {
				if (!it1->GetNodes()->empty()) {
					it2 = it1->GetNodes()->begin();
					while (it2 != it1->GetNodes()->end()) {
						embeddingNode = it2->GetEmbeddingNode();
						//cout << "** id of embedding node is "<<embeddingNode->GetId()<<endl;
						//cout << "size =  "<<embeddingNode->GetEmbeddedNodes()->size()<<endl;
						//for testing-----------cout << " Attempt to free node with @ : "<< embeddingNode << "\n";
						it3 = embeddingNode->GetEmbeddedNodes()->begin();
						it4 = embeddingNode->GetEmbeddedNodes_id()->begin();
						found = false;

						while (!found
								&& it3
										!= embeddingNode->GetEmbeddedNodes()->end()) {
							//for testing-----------cout << it3->GetId() << " vs " << it2->GetId()<< endl;
							if (it3->GetId() == it2->GetId()) {
								//cout << " size before "<<embeddingNode->GetEmbeddedNodes()->size()<<endl;
								it3 = embeddingNode->GetEmbeddedNodes()->erase(
										it3);
								it4 =
										embeddingNode->GetEmbeddedNodes_id()->erase(
												it4);

								ostringstream vdc_id;
								ProvisioningModule prModule;
								vdc_id << "VDC_" << this->GetRequestNumber()
										<< "_VM" << it2->GetId();
								//UNCOMMENT IN THE CLUSTER--------
								prModule.deleteVM(vdc_id.str());
								//cout << " size after "<<embeddingNode->GetEmbeddedNodes()->size()<<endl;
								found = true;
							} else {
								it3++;
							}
						}
						it2->RemoveEmbeddingNode();
						it2->RemoveEmbeddingNode_name();
						it2++;
					}
				}
				it1++;
			}
			this->mapping->SetStateMapping(STATE_NEW);
		}
	}
	this->status = STATE_EXPIRED;

}

void Request::DisplayRequest() {

	//variables
	std::list<Priority_group>::iterator it1;
	std::list<Virtual_node>::iterator it2;
	std::list<Path>::iterator it3;

	//operations
	debug("For Request with ReqNumber: %d, Application: %s\n", this->reqNumber, this->application.c_str());
	debug("Virtual Nodes:\n");
	for (it1 = this->groups.begin(); it1 != this->groups.end(); it1++) {
		debug("GroupID: %d, Number of Nodes: %d\n", it1->GetId(), it1->GetNodes()->size());
		for (it2 = it1->GetNodes()->begin(); it2 != it1->GetNodes()->end();
				it2++) {
			debug("NodeID: %d, bandwidth: %f, cpu: %f, memory: %f, flavour: %f, type: %f\n",
					it2->GetId(), it2->GetBandwidth(), it2->GetCpu(), it2->GetMemory(),
					it2->GetFlavor(), it2->GetType());
		}
	}
	debug("Virtual Links:\n");
	debug("Number of Links: %d\n", links.size());
	for (it3 = this->links.begin(); it3 != this->links.end(); it3++) {
		debug("LinkID: %d, LinkName: %s, bandwidth: %f, SourceNode: %d, DestinationNode: %d\n",
				it3->GetId(), it3->GetName().c_str(), it3->GetBandwidth(), it3->GetSourceNode_id(),
				it3->GetDestinationNode_id());
	}
}

void Request::SetApplication(string application){
	this->application=application;
}

string Request::GetApplication(){
	return this->application;
}

